---
AWSTemplateFormatVersion: '2010-09-09'
Description: AWS CloudFormation template to create a VSCode environment and prepare the HTC-Grid setup
Metadata:
  Author:
    Description: Flamur Gogolli <flamurg@amazon.co.uk>
  License:
    Description: 'Copyright 2025 Amazon.com, Inc. and its affiliates. All Rights Reserved.

            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at
                     http://www.apache.org/licenses/LICENSE-2.0
            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.'

Parameters:
  VSCodeInstanceType:
    Description: Instance type for the VSCode server
    Type: String
    Default: m6i.large
    AllowedValues:
      # General Purpose
      - t3.medium
      - t3.large
      - m5.large
      - m5.xlarge
      - m6i.medium
      - m6i.large
      - m6i.xlarge
      - m7i.medium
      - m7i.large
      - m7i.xlarge
      - m8i.medium
      - m8i.large
      - m8i.xlarge
      # Compute Optimized
      - c5.large
      - c5.xlarge
      - c6i.large
      - c6i.xlarge
      - c7i.large
      - c7i.xlarge
      # Memory Optimized
      - r5.large
      - r6i.large
      - r7i.large
    ConstraintDescription: Must be a valid EC2 instance type.
  TerraformVersion:
    Description: Terraform version to install on VSCode server
    Type: String
    Default: 1.5.7
    ConstraintDescription: Must be a valid Terraform version.
  HTCGridVersion:
    Description: HTC Grid version to install on VSCode server
    Type: String
    Default: latest
    ConstraintDescription: Must be a valid HTC Grid version.
  HTCGridRepo:
    Description: HTC Grid repo to pull on VSCode server
    Type: String
    Default: https://github.com/finos/htc-grid
    ConstraintDescription: Must be a valid HTC Grid repository URL.
  InstanceVolumeSize:
    Type: Number
    Description: The volume size in GB
    Default: 100
  InstanceName:
    Type: String
    Description: VSCode Server EC2 instance name
    Default: HTCGridVSCodeServer
  KubectlVersion:
    Description: kubectl version to install on VSCode server
    Type: String
    Default: stable
    ConstraintDescription: Must be a valid kubectl version.
  HelmVersion:
    Description: Helm version to install on VSCode server
    Type: String
    Default: stable
    ConstraintDescription: Must be a valid Helm version.
  ParticipantRoleARN:
    Description: "ARN of the Participant Role"
    Default: NONE
    Type: String
    ConstraintDescription: This is ONLY used via AWS WorkshopStudio. DON'T change this if you are self-deploying the stack.
  InstanceArchitecture:
    Description: Instance architecture type
    Type: String
    Default: amd64
    AllowedValues:
      - amd64
      - arm64
    ConstraintDescription: Must be amd64 or arm64.
  PythonVersion:
    Description: Python version to install
    Type: String
    Default: 3.13
    AllowedValues:
      - 3.9
      - 3.10
      - 3.11
      - 3.12
      - 3.13
    ConstraintDescription: Must be a valid Python version.

Conditions:
  NotWSParticipant: !Equals [!Ref ParticipantRoleARN, NONE]

Mappings:
  Subnets:
    VPC:
      CIDR: 10.0.0.0/16
    PublicOne:
      CIDR: 10.0.1.0/24
    PublicTwo:
      CIDR: 10.0.2.0/24
    PrivateOne:
      CIDR: 10.0.3.0/24
    PrivateTwo:
      CIDR: 10.0.4.0/24
  ArchitectureMap:
    amd64:
      DownloadArch: amd64
      EC2Arch: x86_64
      AMISuffix: x86_64
    arm64:
      DownloadArch: arm64
      EC2Arch: arm64
      AMISuffix: arm64
  Constants:
    System:
      OSUser: ec2-user
      HomeFolder: /home/ec2-user/environment

Resources:
  ################## PERMISSIONS AND ROLES #################
  VSCodeRole:
    Type: AWS::IAM::Role
    Properties:
      Tags:
      - Key: Environment
        Value: !Ref 'AWS::StackName'
      - Key: Owner
        Value: !If [NotWSParticipant, !Ref 'AWS::NoValue', !Ref ParticipantRoleARN]
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - !Sub 'ec2.${AWS::URLSuffix}'
            - !Sub 'ssm.${AWS::URLSuffix}'
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess'
      Path: "/"

  VSCodeInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
      - !Ref VSCodeRole

  ################## SECRETS MANAGEMENT #################
  VSCodeSecret:
    Type: AWS::SecretsManager::Secret
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      Name: !Ref InstanceName
      Description: VSCode user details
      GenerateSecretString:
        PasswordLength: 32
        SecretStringTemplate: '{"username":"ec2-user"}'
        GenerateStringKey: 'password'
        ExcludePunctuation: true

  SecretPlaintextLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - !Sub lambda.${AWS::URLSuffix}
          Action:
          - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AwsSecretsManager
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref VSCodeSecret

  SecretPlaintextLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Return the value of the secret
      Handler: index.lambda_handler
      Runtime: python3.11
      MemorySize: 128
      Timeout: 10
      Architectures:
        - arm64
      Role: !GetAtt SecretPlaintextLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def is_valid_json(json_string):
            logger.debug('Calling is_valid_jason: %s', json_string)
            try:
              json.loads(json_string)
              logger.info('Secret is in json format')
              return True
            except json.JSONDecodeError:
              logger.info('Secret is in string format')
              return False
          def lambda_handler(event, context):
            try:
              if event['RequestType'] == 'Delete':
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
              else:
                secret_name = (event['ResourceProperties']['SecretArn'])
                secrets_mgr = boto3.client('secretsmanager')
                secret = secrets_mgr.get_secret_value(SecretId = secret_name)
                logger.info('Getting secret from %s', secret_name)
                secret_value = secret['SecretString']
                logger.debug('secret_value: %s', secret_value)
                responseData = {}
                if is_valid_json(secret_value):
                  responseData = secret_value
                else:
                  responseData = {'secret': secret_value}
                logger.debug('responseData: %s', responseData)
                logger.debug('type(responseData): %s', type(responseData))
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData=json.loads(responseData), reason='OK', noEcho=True)
            except Exception as e:
              cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  SecretPlaintext:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt SecretPlaintextLambda.Arn
      ServiceTimeout: 20
      SecretArn: !Ref VSCodeSecret

  ################## NETWORKING RESOURCES #################
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !FindInMap [Subnets, VPC, CIDR]
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-VPC

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-IGW

  GatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      CidrBlock: !FindInMap [Subnets, PublicOne, CIDR]
      VpcId: !Ref VPC
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PublicSubnet1

  PublicOneRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PublicRT1

  PublicOneRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachment
    Properties:
      RouteTableId: !Ref PublicOneRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicOneRouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicOneRouteTable
      SubnetId: !Ref PublicSubnetOne

  PublicSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      CidrBlock: !FindInMap [Subnets, PublicTwo, CIDR]
      VpcId: !Ref VPC
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PublicSubnet2

  PublicTwoRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PublicRT2

  PublicTwoRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachment
    Properties:
      RouteTableId: !Ref PublicTwoRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicTwoRouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicTwoRouteTable
      SubnetId: !Ref PublicSubnetTwo

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for VSCode Server
      SecurityGroupIngress:
        - Description: Allow HTTP from everywhere
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - Description: Allow SSH from the same VPC
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !FindInMap [Subnets, VPC, CIDR]
        - Description: Allow 8080-8085 from the same VPC
          IpProtocol: tcp
          FromPort: 8080
          ToPort: 8085
          CidrIp: !FindInMap [Subnets, VPC, CIDR]
      SecurityGroupEgress:
        - Description: Allow all outbound traffic
          IpProtocol: -1
          CidrIp: 0.0.0.0/0
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-SG

  ################## WAIT CONDITION RESOURCES #################
  WaitForVSCodeStackCreationHandle:
    Type: AWS::CloudFormation::WaitConditionHandle

  WaitConditionVSCode:
    Type: AWS::CloudFormation::WaitCondition
    Properties:
      Handle: !Ref WaitForVSCodeStackCreationHandle
      # wait for 60 minutes before giving up
      Timeout: 3600
      # success or failure signal count
      Count: 1

  ################## VSCODE SERVER SETUP #################
  VSCodeInstanceSSMDoc:  
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: '2.2'
        description: Bootstrap VSCode code-server instance
        parameters:
          ec2Architecture:
            type: String
            default: !FindInMap [ArchitectureMap, !Ref InstanceArchitecture, EC2Arch]
            description: EC2 instance architecture type
          downloadArchitecture:
            type: String
            default: !FindInMap [ArchitectureMap, !Ref InstanceArchitecture, DownloadArch]
            description: Architecture for binary downloads
          cloudfront:
            type: String
            description: CloudFront DNS Name
          cfnResponseUrl:
            type: String
            description: CloudFormation wait condition handle URL
          password:
            type: String
            default: !Sub "${SecretPlaintext.password}"
          terraformVersion:
            type: String
            default: !Sub "${TerraformVersion}"
          kubectlVersion:
            type: String
            default: !Sub "${KubectlVersion}"
          helmVersion:
            type: String
            default: !Sub "${HelmVersion}"
          htcGridVersion:
            type: String
            default: !Sub "${HTCGridVersion}"
          htcGridRepo:
            type: String
            default: !Sub "${HTCGridRepo}"
          pythonVersion:
            type: String
            default: !Sub "${PythonVersion}"
        mainSteps:
          - action: aws:runShellScript
            name: SetupEnvironment
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] Script failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e " Starting the VSCode server bootstrap at: $(date)"
                  echo -e "========================================================"
                  
                  # Create temporary directory
                  export TMP_DIR="$(mktemp -d)"
                  if [[ "${TMP_DIR}" != "/tmp/"* ]]; then
                    export TMP_DIR="/tmp";
                  fi
                  echo -e "[INFO] All the packages will be temporarily downloaded to ${TMP_DIR}"
                  
                  # Set up environment variables
                  echo -e "[INFO] Setting up environment variables"
                  echo LANG=en_US.utf-8 >> /etc/environment
                  echo LC_ALL=en_US.UTF-8 >> /etc/environment
                  
                  # Create workshop directory
                  echo -e "[INFO] Creating workshop directory"
                  mkdir -p "/home/ec2-user/environment"
                  chown ec2-user:ec2-user "/home/ec2-user/environment"
                  
                  # Add workshop directory to user's profile
                  echo "export WORKSHOP_DIR=/home/ec2-user/environment" >> "/home/ec2-user/.bashrc"
                  
                  # Check identity
                  echo -e "[INFO] Running as OS user: $(whoami)"
                  echo -e "[INFO] Running with the following IAM Role:"
                  aws sts get-caller-identity
                  
                  # Increase volume capacity if needed
                  echo -e "[INFO] Checking and increasing volume capacity if needed"
                  if growpart /dev/nvme0n1 1; then xfs_growfs -d /; fi
                  
                  # Update system packages
                  echo -e "[INFO] Updating system packages"
                  dnf update -y
                  dnf install -y git jq gettext unzip cmake
                  
                  # Install Python {{ pythonVersion }}
                  echo -e "[INFO] Installing Python {{ pythonVersion }}"
                  dnf install -y python{{ pythonVersion }} python{{ pythonVersion }}-pip python3-virtualenv

          - action: aws:runShellScript
            name: InstallAWSCLI
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] AWS CLI installation failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "          Installing/Updating AWS CLI"
                  echo -e "========================================================"
                  
                  # Create temporary directory
                  export TMP_DIR="$(mktemp -d)"
                  if [[ "${TMP_DIR}" != "/tmp/"* ]]; then
                    export TMP_DIR="/tmp";
                  fi
                  echo -e "[INFO] All the packages will be temporarily downloaded to ${TMP_DIR}"
                  
                  # Download and install AWS CLI
                  curl --silent --location -o "${TMP_DIR}/awscliv2.zip" "https://awscli.amazonaws.com/awscli-exe-linux-$(uname -m).zip"
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to download AWS CLI"
                    exit 1
                  fi
                  
                  unzip -q "${TMP_DIR}/awscliv2.zip" -d "${TMP_DIR}/awscli"
                  sudo "${TMP_DIR}/awscli/aws/install" --update
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to install AWS CLI"
                    exit 1
                  fi
                  
                  rm -rf "${TMP_DIR}/awscliv2.zip" "${TMP_DIR}/awscli"
                  
                  # Configure AWS
                  export ACCOUNT_ID="$(aws sts get-caller-identity --output text --query Account)"
                  export AWS_REGION="$(curl -s 169.254.169.254/latest/dynamic/instance-identity/document | jq -r '.region')"
                  
                  # Set up AWS environment variables
                  echo "export ACCOUNT_ID=\"${ACCOUNT_ID}\"" >> "/home/ec2-user/.bashrc"
                  echo "export AWS_REGION=\"${AWS_REGION}\"" >> "/home/ec2-user/.bashrc"
                  aws configure set default.region "${AWS_REGION}"
                  
                  # Verify installation
                  if aws --version > /dev/null 2>&1; then
                    echo -e "[INFO] Successfully installed AWS CLI: $(aws --version)"
                  else
                    echo -e "[ERROR] AWS CLI installation verification failed"
                    exit 1
                  fi

          - action: aws:runShellScript
            name: InstallKubectl
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] kubectl installation failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "                  Installing kubectl"
                  echo -e "========================================================"
                  
                  # Create temporary directory
                  export TMP_DIR="$(mktemp -d)"
                  if [[ "${TMP_DIR}" != "/tmp/"* ]]; then
                    export TMP_DIR="/tmp";
                  fi
                  echo -e "[INFO] All the packages will be temporarily downloaded to ${TMP_DIR}"
                  
                  # Check if a specific version is requested
                  if [ "{{ kubectlVersion }}" = "stable" ]; then
                    # Download stable version
                    echo -e "[INFO] Installing stable kubectl version"
                    curl -L -o "${TMP_DIR}/kubectl" "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/{{ downloadArchitecture }}/kubectl"
                    if [ $? -ne 0 ]; then
                      echo -e "[ERROR] Failed to download kubectl"
                      exit 1
                    fi
                  else
                    # Download specific version
                    echo -e "[INFO] Installing kubectl version {{ kubectlVersion }}"
                    curl --silent --location -o "${TMP_DIR}/kubectl" \
                      "https://storage.googleapis.com/kubernetes-release/release/v{{ kubectlVersion }}/bin/linux/{{ downloadArchitecture }}/kubectl"
                    if [ $? -ne 0 ]; then
                      echo -e "[ERROR] Failed to download kubectl"
                      exit 1
                    fi
                  fi
                  
                  # Verify file exists before chmod
                  if [ ! -f "${TMP_DIR}/kubectl" ]; then
                    echo -e "[ERROR] kubectl binary not found at ${TMP_DIR}/kubectl"
                    exit 1
                  fi
                  
                  chmod +x "${TMP_DIR}/kubectl"
                  mv "${TMP_DIR}/kubectl" "/usr/local/bin/kubectl"
                  
                  # Verify installation
                  if kubectl version --client 2>/dev/null; then
                    echo -e "[INFO] Successfully installed kubectl version: $(kubectl version --client --output=yaml | grep gitVersion)"
                  else
                    echo -e "[ERROR] Failed to install kubectl"
                    exit 1
                  fi

          - action: aws:runShellScript
            name: InstallTerraform
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] Terraform installation failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "                   Installing Terraform"
                  echo -e "========================================================"
                  
                  # Create temporary directory
                  export TMP_DIR="$(mktemp -d)"
                  if [[ "${TMP_DIR}" != "/tmp/"* ]]; then
                    export TMP_DIR="/tmp";
                  fi
                  echo -e "[INFO] All the packages will be temporarily downloaded to ${TMP_DIR}"
                  
                  # Download and install Terraform
                  echo -e "[INFO] Downloading Terraform version {{ terraformVersion }}"
                  curl --silent --location -o "${TMP_DIR}/terraform.zip" \
                    "https://releases.hashicorp.com/terraform/{{ terraformVersion }}/terraform_{{ terraformVersion }}_linux_{{ downloadArchitecture }}.zip"
                  
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to download Terraform"
                    exit 1
                  fi
                  
                  # Verify file exists and has content
                  if [ ! -f "${TMP_DIR}/terraform.zip" ] || [ ! -s "${TMP_DIR}/terraform.zip" ]; then
                    echo -e "[ERROR] Terraform zip file not found or empty at ${TMP_DIR}/terraform.zip"
                    exit 1
                  fi
                  
                  echo -e "[INFO] Extracting Terraform"
                  mkdir -p "${TMP_DIR}/terraform"
                  unzip -q "${TMP_DIR}/terraform.zip" -d "${TMP_DIR}/terraform"
                  
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to extract Terraform zip file"
                    exit 1
                  fi
                  chmod +x "${TMP_DIR}/terraform/terraform"
                  mv "${TMP_DIR}/terraform/terraform" "/usr/local/bin/terraform"
                  rm -f "${TMP_DIR}/terraform.zip"
                  
                  # Verify installation
                  if terraform version; then
                    echo -e "[INFO] Successfully installed Terraform"
                  else
                    echo -e "[ERROR] Failed to install Terraform"
                    exit 1
                  fi

          - action: aws:runShellScript
            name: InstallHelm
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] Helm installation failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "                     Installing Helm"
                  echo -e "========================================================"
                  
                  # Create temporary directory
                  export TMP_DIR="$(mktemp -d)"
                  if [[ "${TMP_DIR}" != "/tmp/"* ]]; then
                    export TMP_DIR="/tmp";
                  fi
                  echo -e "[INFO] All the packages will be temporarily downloaded to ${TMP_DIR}"
                  
                  # Check if a specific version is requested
                  if [ "{{ helmVersion }}" = "stable" ]; then
                    # Use the official installation script
                    echo -e "[INFO] Installing stable Helm version"
                    curl -fsSL -o "${TMP_DIR}/get_helm.sh" https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
                    chmod 700 "${TMP_DIR}/get_helm.sh"
                    "${TMP_DIR}/get_helm.sh"
                  else
                    # Download specific version
                    echo -e "[INFO] Installing Helm version {{ helmVersion }}"
                    curl --silent --location -o "${TMP_DIR}/helm.tar.gz" \
                      "https://get.helm.sh/helm-v{{ helmVersion }}-linux-{{ downloadArchitecture }}.tar.gz"
                    
                    mkdir -p "${TMP_DIR}/helm"
                    tar -zxf "${TMP_DIR}/helm.tar.gz" -C "${TMP_DIR}/helm/"
                    chmod +x "${TMP_DIR}/helm/linux-{{ downloadArchitecture }}/helm"
                    mv "${TMP_DIR}/helm/linux-{{ downloadArchitecture }}/helm" "/usr/local/bin/"
                    rm -f "${TMP_DIR}/helm.tar.gz"
                  fi
                  
                  # Verify installation
                  if helm version; then
                    echo -e "[INFO] Successfully installed Helm"
                  else
                    echo -e "[ERROR] Failed to install Helm"
                    exit 1
                  fi

          - action: aws:runShellScript
            name: SetupCodeServer
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] code-server setup failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "              Setting up code-server"
                  echo -e "========================================================"
                  
                  # Set HOME to prevent unbound variable errors
                  export HOME="/home/ec2-user"
                  
                  # Install dependencies
                  dnf install -y nginx
                  
                  # Install code-server
                  curl -fsSL https://code-server.dev/install.sh | sh -s -- --method=standalone --version=4.16.1 --prefix=/usr/local
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to install code-server"
                    exit 1
                  fi
                  
                  # Verify installation
                  if /usr/local/bin/code-server --version > /dev/null 2>&1; then
                    echo -e "[INFO] Successfully installed code-server: $(/usr/local/bin/code-server --version)"
                  else
                    echo -e "[ERROR] code-server installation verification failed"
                    exit 1
                  fi
                  
                  # Configure code-server
                  mkdir -p "/home/ec2-user/.config/code-server"
                  cat > "/home/ec2-user/.config/code-server/config.yaml" << EOF
                  bind-addr: 127.0.0.1:8080
                  auth: password
                  password: {{ password }}
                  cert: false
                  EOF
                  
                  # Set up code-server service
                  cat > /etc/systemd/system/code-server.service << EOF
                  [Unit]
                  Description=code-server
                  After=network.target
                  
                  [Service]
                  Type=simple
                  User=ec2-user
                  ExecStart=/usr/local/bin/code-server
                  Restart=always
                  
                  [Install]
                  WantedBy=multi-user.target
                  EOF
                  
                  # Configure nginx
                  cat > /etc/nginx/conf.d/code-server.conf << EOF
                  server {
                      listen 80;
                      listen [::]:80;
                      server_name {{ cloudfront }};
                      
                      location / {
                          proxy_pass http://localhost:8080/;
                          proxy_set_header Host \$host;
                          proxy_set_header Upgrade \$http_upgrade;
                          proxy_set_header Connection upgrade;
                          proxy_set_header Accept-Encoding gzip;
                      }
                  }
                  EOF
                  
                  # Configure VSCode settings
                  mkdir -p "/home/ec2-user/.local/share/code-server/User/"
                  cat > "/home/ec2-user/.local/share/code-server/User/settings.json" << EOF
                  {
                    "extensions.autoUpdate": false,
                    "extensions.autoCheckUpdates": false,
                    "terminal.integrated.cwd": "/home/ec2-user/environment",
                    "telemetry.telemetryLevel": "off",
                    "security.workspace.trust.startupPrompt": "never",
                    "security.workspace.trust.enabled": false,
                    "security.workspace.trust.banner": "never",
                    "security.workspace.trust.emptyWindow": false,
                    "editor.indentSize": "tabSize",
                    "editor.tabSize": 2,
                    "python.testing.pytestEnabled": true,
                    "auto-run-command.rules": [
                      {
                        "command": "workbench.action.terminal.new"
                      }
                    ]
                  }
                  EOF
                  
                  # Set proper ownership
                  chown -R ec2-user:ec2-user "/home/ec2-user/.config"
                  chown -R ec2-user:ec2-user "/home/ec2-user/.local"
                  
                  # Start services
                  systemctl enable code-server
                  systemctl start code-server
                  systemctl enable nginx
                  systemctl restart nginx

          - action: aws:runShellScript
            name: InstallVSCodeExtensions
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] VSCode extensions installation failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "            Installing VSCode Extensions"
                  echo -e "========================================================"
                  
                  # Install extensions as the correct user
                  echo -e "[INFO] Installing VSCode extensions"
                  
                  # Create a script file for installing extensions
                  cat > "${TMP_DIR}/install_extensions.sh" << 'EOF'
                  #!/bin/bash
                  set -e
                  
                  # AWS extensions
                  /usr/local/bin/code-server --install-extension AmazonWebServices.aws-toolkit-vscode
                  /usr/local/bin/code-server --install-extension AmazonWebServices.amazon-q-vscode
                  
                  # Kubernetes extensions
                  /usr/local/bin/code-server --install-extension ms-kubernetes-tools.vscode-kubernetes-tools
                  
                  # Terraform extensions
                  /usr/local/bin/code-server --install-extension HashiCorp.terraform
                  
                  # Python extensions
                  /usr/local/bin/code-server --install-extension ms-python.python
                  
                  # Development tools
                  /usr/local/bin/code-server --install-extension ms-vscode.makefile-tools
                  /usr/local/bin/code-server --install-extension redhat.vscode-yaml
                  /usr/local/bin/code-server --install-extension mohsen1.prettify-json
                  /usr/local/bin/code-server --install-extension ms-vscode-remote.remote-containers
                  /usr/local/bin/code-server --install-extension esbenp.prettier-vscode
                  /usr/local/bin/code-server --install-extension ms-azuretools.vscode-docker
                  EOF
                  
                  # Make the script executable
                  chmod +x "${TMP_DIR}/install_extensions.sh"
                  
                  # Run the script as the correct user
                  sudo -H -u "ec2-user" bash "${TMP_DIR}/install_extensions.sh"
                  
                  if [ $? -ne 0 ]; then
                    echo -e "[WARN] Some extensions may have failed to install. This is not critical and the server will still function."
                  fi

          - action: aws:runShellScript
            name: DownloadHTCGrid
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] HTC-Grid download failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "                   Downloading HTC-Grid"
                  echo -e "========================================================"
                  
                  export HTCGRID_HOME="/home/ec2-user/environment"
                  cd "${HTCGRID_HOME}"
                  
                  # Check if htc-grid directory already exists
                  if [ -e "htc-grid" ]; then
                    export OLD_HTCGRID_DIR="htc-grid.$(date "+%F-%T" | sed 's|:|_|g')"
                    mv htc-grid "${OLD_HTCGRID_DIR}"
                    if [ $? -eq 0 ]; then
                      echo -e "[WARN] Found existing htc-grid directory. Renaming to:\n${OLD_HTCGRID_DIR}"
                    else
                      echo -e "[ERROR] Found existing htc-grid directory, however failed to rename it as:\n${OLD_HTCGRID_DIR}"
                      exit 1
                    fi
                  fi
                  
                  # Download HTC Grid
                  if [ "{{ htcGridVersion }}" == "latest" ]; then
                    export HTCGRID_VERSION="$(curl -Ls -o /dev/null -w %{url_effective} {{ htcGridRepo }}/releases/latest | awk -F '/v' '{ print $NF }')";
                    echo -e "[INFO] The value for HTCGRID_VERSION is 'latest'. Discovered the latest release as: ${HTCGRID_VERSION}"
                  else
                    export HTCGRID_VERSION="{{ htcGridVersion }}"
                  fi
                  
                  if [ "${HTCGRID_VERSION}" == "main" ]; then
                    export HTCGRID_URI_REF="heads/main";
                  else
                    export HTCGRID_URI_REF="tags/v${HTCGRID_VERSION}";
                  fi
                  
                  echo -e "[INFO] Downloading HTC Grid release ${HTCGRID_VERSION} from repo:\n{{ htcGridRepo }}"
                  
                  # Create a temporary file for the download
                  export DOWNLOAD_FILE="${TMP_DIR}/htc-grid.tar.gz"
                  
                  curl --silent --location \
                    -o "${DOWNLOAD_FILE}" \
                    "{{ htcGridRepo }}/archive/refs/${HTCGRID_URI_REF}.tar.gz"
                  
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to download HTC Grid from {{ htcGridRepo }}"
                    exit 1
                  fi
                  
                  # Verify file exists and has content
                  if [ ! -f "${DOWNLOAD_FILE}" ] || [ ! -s "${DOWNLOAD_FILE}" ]; then
                    echo -e "[ERROR] HTC Grid tar.gz file not found or empty at ${DOWNLOAD_FILE}"
                    exit 1
                  fi
                  
                  echo -e "[INFO] Extracting HTC Grid"
                  cd "${HTCGRID_HOME}"
                  tar -zxf "${DOWNLOAD_FILE}"
                  
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to extract htc-grid.tar.gz"
                    exit 1
                  fi
                  
                  rm -f htc-grid.tar.gz
                  
                  # Rename the directory to htc-grid
                  if [ "${HTCGRID_VERSION}" == "main" ]; then
                    mv "htc-grid-main" "htc-grid"
                  else
                    mv "htc-grid-${HTCGRID_VERSION}" "htc-grid"
                  fi
                  
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to rename htc-grid directory"
                    exit 1
                  fi
                  
                  # Set proper ownership
                  chown -R ec2-user:ec2-user "${HTCGRID_HOME}"
                  
                  if [ $? -ne 0 ]; then
                    echo -e "[ERROR] Failed to set ownership on ${HTCGRID_HOME}"
                    exit 1
                  fi
                  
                  echo -e "[INFO] Successfully downloaded HTC-Grid to [${HTCGRID_HOME}/htc-grid] with version: ${HTCGRID_VERSION}"

          - action: aws:runShellScript
            name: NotifyCloudFormation
            inputs:
              runCommand:
                - |
                  #!/bin/bash
                  set -e
                  
                  # Set up error handling
                  trap 'echo "[ERROR] CloudFormation notification failed" > /tmp/bootstrap_failed' ERR
                  
                  echo -e "========================================================"
                  echo -e "            Notifying CloudFormation"
                  echo -e "========================================================"
                  
                  # Generate a unique ID for the signal
                  export UNIQUE_ID=$(uuidgen | sed 's/[-]//g')
                  echo "[INFO] Generated unique ID: ${UNIQUE_ID}"
                  
                  # Check if any previous steps failed
                  if [ -f "/tmp/bootstrap_failed" ]; then
                    echo "[ERROR] Previous bootstrap steps failed. Sending failure signal to CloudFormation."
                    
                    # Send failure signal to CloudFormation
                    export CFN_RESPONSE_URL="{{ cfnResponseUrl }}"
                    
                    if [ -z "${CFN_RESPONSE_URL}" ]; then
                      echo "[ERROR] CloudFormation response URL is empty"
                      exit 1
                    fi
                    
                    curl -v -X PUT -H 'Content-Type:' \
                      --data-binary '{"Status":"FAILURE","Reason":"VSCode Server Setup Failed. Check SSM logs for details.","UniqueId":"'${UNIQUE_ID}'","Data":"VSCode Server setup failed"}' \
                      "${CFN_RESPONSE_URL}"
                    
                    exit 1
                  else
                    # Send success signal to CloudFormation
                    export CFN_RESPONSE_URL="{{ cfnResponseUrl }}"
                    echo "[INFO] Sending success signal to CloudFormation"
                    
                    if [ -z "${CFN_RESPONSE_URL}" ]; then
                      echo "[ERROR] CloudFormation response URL is empty"
                      exit 1
                    fi
                    
                    curl -v -X PUT -H 'Content-Type:' \
                      --data-binary '{"Status":"SUCCESS","Reason":"VSCode Server Setup Complete","UniqueId":"'${UNIQUE_ID}'","Data":"VSCode Server is ready"}' \
                      "${CFN_RESPONSE_URL}"
                    
                    if [ $? -eq 0 ]; then
                      echo "[INFO] Successfully notified CloudFormation"
                    else
                      echo "[ERROR] Failed to notify CloudFormation"
                      exit 1
                    fi
                  fi

  VSCodeInstanceSSMAssociation:
    Type: AWS::SSM::Association
    Properties:
      Name: !Ref VSCodeInstanceSSMDoc
      Targets:
        - Key: tag:SSMBootstrap
          Values: 
          - !FindInMap [ArchitectureMap, !Ref InstanceArchitecture, EC2Arch]
      Parameters:
        ec2Architecture: 
        - !FindInMap [ArchitectureMap, !Ref InstanceArchitecture, EC2Arch]
        downloadArchitecture:
        - !FindInMap [ArchitectureMap, !Ref InstanceArchitecture, DownloadArch]
        cloudfront: 
        - !GetAtt CloudFrontDistribution.DomainName
        cfnResponseUrl:
        - !Ref WaitForVSCodeStackCreationHandle
        password:
        - !GetAtt SecretPlaintext.password
        terraformVersion:
        - !Ref TerraformVersion
        kubectlVersion:
        - !Ref KubectlVersion
        helmVersion:
        - !Ref HelmVersion
        htcGridVersion:
        - !Ref HTCGridVersion
        htcGridRepo:
        - !Ref HTCGridRepo
        pythonVersion:
        - !Ref PythonVersion

  ################## EC2 RESOURCES #################
  VSCodeLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub ${AWS::StackName}-launch-template
      LaunchTemplateData:
        BlockDeviceMappings:
          - Ebs:
              VolumeSize: !Ref InstanceVolumeSize
              VolumeType: gp3
              DeleteOnTermination: true
              Encrypted: true
            DeviceName: /dev/sda1
        Monitoring: 
          Enabled: true
        ImageId: !Sub 
          - '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-${AMISuffix}:1}}'
          - AMISuffix: !FindInMap [ArchitectureMap, !Ref InstanceArchitecture, AMISuffix]
        InstanceType: !Ref VSCodeInstanceType
        SecurityGroupIds:
          - !Ref SecurityGroup
        IamInstanceProfile: 
          Name: !Ref VSCodeInstanceProfile
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            echo "Setting up VSCode Server"
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: SSMBootstrap
                Value: !FindInMap [ArchitectureMap, !Ref InstanceArchitecture, EC2Arch]
              - Key: Name
                Value: !Ref InstanceName
              - Key: Environment
                Value: !Ref 'AWS::StackName'

  AutoScalingGroupVSCode:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn:
      - VSCodeInstanceSSMAssociation
    Properties:
      AutoScalingGroupName: !Sub ${AWS::StackName}-ASG
      VPCZoneIdentifier:
        - !Ref PublicSubnetOne
        - !Ref PublicSubnetTwo
      LaunchTemplate:
        LaunchTemplateId: !Ref VSCodeLaunchTemplate
        Version: !GetAtt VSCodeLaunchTemplate.LatestVersionNumber
      TargetGroupARNs:
        - !Ref TargetGroup
      MinSize: 1
      MaxSize: 1
      DesiredCapacity: 1
      HealthCheckType: EC2
      HealthCheckGracePeriod: 300
      Tags:
        - Key: Name
          Value: !Ref InstanceName
          PropagateAtLaunch: true
        - Key: Environment
          Value: !Ref 'AWS::StackName'
          PropagateAtLaunch: true

  ################## CLOUDFRONT RESOURCES #################
  VSCodeInstanceCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        DefaultTTL: 86400
        MaxTTL: 31536000
        MinTTL: 1
        Name: !Join ['-', ['VSCodeServer', !Select [4, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: all
          EnableAcceptEncodingGzip: False
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers:
              - Accept-Charset
              - Authorization
              - Origin
              - Accept
              - Referer
              - Host
              - Accept-Language
              - Accept-Encoding
              - Accept-Datetime
          QueryStringsConfig:
            QueryStringBehavior: all

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: True
        HttpVersion: http2
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - PATCH
            - POST
            - DELETE
          CachePolicyId: !Ref VSCodeInstanceCachePolicy
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3 # Managed-AllViewer
          TargetOriginId: !Sub CloudFront-${AWS::StackName}
          ViewerProtocolPolicy: allow-all
        Origins:
          - DomainName: !GetAtt ApplicationLoadBalancer.DNSName
            Id: !Sub CloudFront-${AWS::StackName}
            CustomOriginConfig:
              OriginProtocolPolicy: http-only
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-CloudFront
        - Key: Environment
          Value: !Ref 'AWS::StackName'

  ################## LOAD BALANCER RESOURCES #################
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${AWS::StackName}-alb
      Scheme: internet-facing
      SecurityGroups:
        - !Ref SecurityGroup
      Subnets:
        - !Ref PublicSubnetOne
        - !Ref PublicSubnetTwo
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ALB
        - Key: Environment
          Value: !Ref 'AWS::StackName'

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPath: /
      Name: !Sub ${AWS::StackName}-tg
      Port: 80
      Protocol: HTTP
      TargetType: instance
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-TG
        - Key: Environment
          Value: !Ref 'AWS::StackName'
  
  Listener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          ForwardConfig:
            TargetGroups:
              - TargetGroupArn: !Ref TargetGroup
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP

Outputs:
  VSCodeURL:
    Description: VSCode Server URL
    Value: !Sub https://${CloudFrontDistribution.DomainName}/?folder=/home/ec2-user/environment
  VSCodePassword:
    Description: VSCode Server Password
    Value: !GetAtt SecretPlaintext.password
